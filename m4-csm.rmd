# Initialize
## Set Options
```{r purl = TRUE}
DIR = 'D:/Onedrive/__Projects/econforecasting'
M3_PATH = 'D:/Onedrive/__Projects/econforecasting/model-outputs/[2021-07-28] m3.rds'
PACKAGE_DIR = 'D:/Onedrive/__Projects/econforecasting/r-package' # Path to package with helper functions
INPUT_DIR = 'D:/Onedrive/__Projects/econforecasting/model-inputs' # Path to directory with constants.r (SQL DB info, SFTP info, etc.)
OUTPUT_DIR = 'D:/Onedrive/__Projects/econforecasting/model-outputs'
```

# Initialize
```{r}
# General purpose
library(tidyverse) # General
library(data.table) # General
library(devtools) # General
library(lubridate) # Dates
library(glue) # String Interpolation
# Data parse/import
library(jsonlite) # JSON Parser
library(rvest) # HTML Parser
library(httr) # CURL Interface
# SQL/Apache Spark
library(DBI) # SQL Interface
# library(RPostgres) # PostgreSQL
# library(rsparklyr) # Spark
# My package
devtools::load_all(path = PACKAGE_DIR)
devtools::document(PACKAGE_DIR)
# library(econforecasting)

# Set working directory
setwd(DIR)

# Read constants
source(file.path(INPUT_DIR, 'constants.r'))
```

## Load RDS
```{r}
local({
	
	rds = readRDS(M3_PATH)

	p <<- rds$p
	m <<- rds$m
	h <<- rds$h
})
```


# Input Prep

## Aggregate Inputs to Quarterly
```{r}
local({
	
	# Get historical forecasts
	histDf =
		h$flatDf %>%
		split(., .$varname)  %>%
		purrr::map_dfr(., function(x)
			# Get monthly data if it exists, quarterly otherwise
			x %>%
				{
					if ('m' %in% unique(x$freq)) dplyr::filter(., form == 'st' & freq == 'm')
					else dplyr::filter(., form == 'st' & freq == 'q')
				} %>%
				dplyr::transmute(., varname, freq, date, value)
			)

	
	# Get exogenous qualitative forecasts
	qualDf =
		m$qual$predFlat %>%
		dplyr::filter(., form == 'st') %>%
		dplyr::transmute(., scenarioname, varname, freq = 'm', date, value)
	

	# Iterate through scenarios, combine and aggregate to quarterly
	exogDfs =
		qualDf %>%
    	split(., .$scenarioname) %>%
		lapply(., function(x)
			dplyr::bind_rows(histDf, x) %>%
				dplyr::arrange(., varname, date) %>%
				dplyr::mutate(., strdate = paste0(year(date), 'Q', quarter(date))) %>%
				dplyr::group_by(., varname, strdate) %>%
				dplyr::group_split(.) %>%
				lapply(., function(y) {
					if (y$freq[[1]] == 'm' && nrow(y) == 3) tibble(varname = y$varname[[1]], value = mean(y$value), strdate = y$strdate[[1]])		else if (y$freq[[1]] == 'm' && nrow(y) < 3) NA
					else if (y$freq[[1]] == 'q') dplyr::select(y, varname, value, strdate)
					}) %>%
				purrr::keep(., function(x) is_tibble(x)) %>%
				dplyr::bind_rows(.) %>%
				dplyr::mutate(., date = econforecasting::strdateToDate(strdate)) %>%
				dplyr::select(., -strdate) %>%
				tidyr::pivot_wider(., names_from  = 'varname', values_from = 'value') %>%
				dplyr::arrange(., date) %>%
				dplyr::filter(., date >= as.Date('2010-01-01'))
			)

	
	exogFlat =
		exogDfs %>%
		purrr::imap_dfr(., function(x, i)
			tidyr::pivot_longer(x, -date, names_to = 'varname', values_to = 'value') %>%
				dplyr::mutate(., scenarioname = i) %>%
				na.omit(.)
		)

	
	m$csm$exogDfs <<- exogDfs
	m$csm$exogFlat <<- exogFlat
})
```



# CSM

## Forecast Periods
```{r}
local({
	
	# Pull start date by finding the first date where at least one CORE.ENDOG variables is non-empty
	startDate =
		m$csm$exogDfs$baseline %>%
		dplyr::select(., date, dplyr::filter(p$variablesDf, core_structural == 'core.endog')$varname) %>%
		dplyr::filter(., date >= as.Date('2020-01-01')) %>%
		tidyr::pivot_longer(., -date, names_to = 'varname') %>%
	    dplyr::mutate(., isNa = ifelse(is.na(value), 1, 0)) %>%
	    dplyr::group_by(., date) %>%
	    dplyr::summarize(., countNa = sum(isNa), .groups = 'drop') %>%
		dplyr::filter(., countNa > 0) %>%
		dplyr::arrange(., date) %>%
		head(., 1) %>%
		.$date
	
	
	# Pull end date by last date of CORE.EXOG variables
	endDate =
		m$csm$exogDfs$baseline %>%
	    dplyr::select(., date, dplyr::filter(p$variablesDf, core_structural == 'core.exog')$varname) %>%
	    dplyr::filter(., date >= as.Date('2020-01-01')) %>%
	    tidyr::pivot_longer(., -date, names_to = 'varname') %>%
	    dplyr::mutate(., isNa = ifelse(is.na(value), 1, 0)) %>%
	    dplyr::group_by(., date) %>%
	    dplyr::summarize(., countNa = sum(isNa), .groups = 'drop') %>%
	    dplyr::filter(., countNa == 0) %>%
	    dplyr::arrange(., date) %>%
	    tail(., 1) %>%
	    .$date

	
	
	m$csm$startDate <<- startDate
	m$csm$endDate <<- endDate
})
```

## Estimate Coefficients
```{r}
local({
	
	# Get historical data
	histDf =
		h$st$q %>%
		dplyr::filter(., date < m$csm$startDate)
	

    histDfAll =
        histDf %>%
        dplyr::bind_cols(
            .,
            constant = 1,
            lapply(1:4, function(l)
                dplyr::transmute_if(histDf, is.numeric, function(x) dplyr::lag(x, l)) %>%
                    dplyr::rename_with(., function(x) paste0(x, '.l', l))
                )
            )

    
    	
    # Now create coefficient matrices
    # Get steady-state values
    ss =
        h$base$q %>%
        na.omit(.) %>%
        dplyr::filter(., date == max(date)) %>%
        dplyr::select(., -date) %>%
        purrr::transpose(.) %>%
        .[[1]]


	coefMatsIdentity =
        list(
            gdp =
        		tibble(gdp = 1, pce = -1 * ss$pce/ss$gdp, pdi = -1 * ss$pdi/ss$gdp, im = ss$im/ss$gdp, ex = -1 * ss$ex/ss$gdp, govt = -1 * ss$govt/ss$gdp)
            )
	

    # Iterate through equations
    eqnsList =
        list(
            pce = 'pce = constant + ue',
            pdin = 'pdin = constant + ue + _lma2.pdin',
            pdir = 'pdir = constant + ue + hpi + _lma2.pdir',
            im = 'im = constant + ue + _lma2.im',
            ex = 'ex = constant + ue + _lma2.ex',
            govt = 'govt = constant + _lma2.govt',
            pi = 'pi = constant + pid',
            pdi = 'pdi = pdin + pdir',
        	pceg = 'pceg = pce + _lma2.pceg + _lma2.ue',
        	pces = 'pces = pce + _lma2.pces + _lma2.ue',
            govtf = 'govtf = govt + _lma2.govtf + _lma2.ue',
            govts = 'govts = govt + _lma2.govts + _lma2.ue',
            houst = 'houst = hpi + _lma2.houst + _lma2.ue + mort30y',
            hsold = 'hsold = hpi + _lma2.hsold + _lma2.ue + mort30y',
            vix = 'vix = vix.l1 + spy + spy.l1'
        )

    # Get estimated coefficient matrices
    coefMatsEstimated = purrr::map(eqnsList, function(eqn) {
        message(eqn)
        
        yCoef = eqn %>% str_split_fixed(., '=', 2) %>% .[1, 1] %>% str_squish(.)
        
        xCoefs =
            eqn %>%
            str_split_fixed(., '=', 2) %>%
            .[1, 2] %>%
            str_split(., '\\+') %>%
            .[[1]] %>%
            str_squish(.) %>%
            purrr::map_dfr(., function(x)
                if (str_detect(x, '_ma2')) tibble(coefname = paste0(str_replace(x, coll('_ma2.'), ''), c('', '.l1')), adj = .5)
                else if (str_detect(x, '_lma2')) tibble(coefname = paste0(str_replace(x, coll('_lma2.'), ''), c('.l1', '.l2')), adj = .25)
                else tibble(coefname = x, adj = 1)
                )
    
        inputDf =
            histDfAll %>%
            dplyr::select(., date, all_of(c(yCoef, xCoefs$coefname))) %>%
            na.omit(.)
        
        yMat = inputDf %>% dplyr::select(., all_of(yCoef)) %>% as.matrix(.)
        xMat = inputDf %>% dplyr::select(., all_of(xCoefs$coefname)) %>% as.matrix(.)
        
        
        coefRes =
            solve(t(xMat) %*% xMat) %*% (t(xMat) %*% yMat) %>%
            as.data.frame(.) %>%
            rownames_to_column(.) %>%
            setNames(., c('coefname', 'value')) %>%
            as_tibble(.) %>%
            dplyr::left_join(xCoefs, by = 'coefname') %>%
            dplyr::transmute(., coefname, value = value * adj * -1) %>%
            dplyr::bind_rows(tibble(coefname = yCoef, value = 1), .) %>%
            tidyr::pivot_wider(., names_from = 'coefname')
        
        return(coefRes)
    })
    
    
    
    # Seperate endogeneous (estimated) and exogenous matrices
    endogVars = names(c(coefMatsIdentity, coefMatsEstimated))
    exogVars = p$variablesDf %>% dplyr::filter(., core_structural == 'core.exog') %>% .$varname
    
    coefMat =
        purrr::imap_dfr(c(coefMatsIdentity, coefMatsEstimated), function(x, i) dplyr::bind_cols(coefname = i, x)) %>%
        replace(., is.na(.), 0)


    m$csm$endogVars <<- endogVars
    m$csm$exogVars <<- exogVars
    m$csm$coefMat <<- coefMat
})
```

## CSM Forecasting - Quarterly (All)
```{r}
local({
    
	coefMat = m$csm$coefMat

	forecasts = lapply(m$csm$exogDfs, function(exogScenarioDf) {
		
	    # Create exog df - start 4 quarters before forecast start date
	    exogDf =
			exogScenarioDf %>%
	    	dplyr::filter(., date >= lubridate::add_with_rollback(m$csm$startDate, months(-12)) & date <= m$csm$endDate)
	
	
	    # Pass accumulator new exogenous variables each time
	    resDf = purrr::reduce(5:nrow(exogDf), function(df, .row) {
	        
	        allCoefDf =
	            df %>%
	            dplyr::bind_cols(
	                .,
	                constant = 1,
	                lapply(1:4, function(l)
	                    dplyr::transmute_if(df, is.numeric, function(x) dplyr::lag(x, l)) %>%
	                        dplyr::rename_with(., function(x) paste0(x, '.l', l))
	                    )
	                ) %>%
	            dplyr::select(., c('date', colnames(coefMat) %>% .[. != 'coefname'])) %>%
	            .[.row, ]
	        
	        
	        bMatVars = allCoefDf %>% tidyr::pivot_longer(., -date) %>% dplyr::filter(., is.na(value)) %>% .$name
	        dMatVars = allCoefDf %>% tidyr::pivot_longer(., -date) %>% dplyr::filter(., !is.na(value)) %>% .$name
	        # Only keep equations where not already filled
	        cMat =
	        	coefMat %>% dplyr::filter(., coefname %in% bMatVars) %>% dplyr::select(., all_of(dMatVars)) %>% as.matrix(.) %>%
	        	{. * -1}
	        aMat = coefMat %>% dplyr::filter(., coefname %in% bMatVars) %>% dplyr::select(., all_of(bMatVars)) %>% as.matrix(.)
	        dMat = allCoefDf %>% dplyr::select(., all_of(dMatVars)) %>% as.matrix(.) %>% t(.)
	        
	        bMat = solve(aMat) %*% (cMat %*% dMat)
	        bMatVec = bMat %>% as.data.frame(.) %>% rownames_to_column(.) %>% {setNames(.$V1, .$rowname)}
	        
	        for (varname in names(bMatVec)) {
	            df[[.row, varname]] = bMatVec[[varname]]
	        }
	        
	        return(df)
	    }, .init = exogDf)
	    
	    
	    pred = resDf %>% dplyr::filter(., date >= m$csm$startDate) %>% dplyr::select(., all_of(c('date', m$csm$endogVars)))

	})
    
    m$csm$predst <<- 
})
```


## Convert to base values
```{r}
local({
	
	
})
```


## Delete quarterly forecasts on quarters where monthly data exists -> replace with monthly forecasts and interpolate with remaining monthly forecasts
```{r}

```



# Aggregate

## Model stacking - quarterly
```{r}
local({
	
	# Combine with nowcasts and external forecasts
	
	
})
```


## Model stacking - monthly
```{r}
local({
	
	# Convert all to monthly, then deaggregate
	
	
})
```


# Combine with Nowcasts
## Merge CSM - NC - EXTERNAL
```{r}
local({
    
	# Merge external from SPF
	

})
```

## Re-Aggregate
```{r}

```

