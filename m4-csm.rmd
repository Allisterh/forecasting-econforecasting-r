# Initialize
## Set Options
```{r purl = TRUE}
DIR = 'D:/Onedrive/__Projects/econforecasting'
M3_PATH = 'D:/Onedrive/__Projects/econforecasting/model-outputs/[2021-07-26] m3.rds'
PACKAGE_DIR = 'D:/Onedrive/__Projects/econforecasting/r-package' # Path to package with helper functions
INPUT_DIR = 'D:/Onedrive/__Projects/econforecasting/model-inputs' # Path to directory with constants.r (SQL DB info, SFTP info, etc.)
OUTPUT_DIR = 'D:/Onedrive/__Projects/econforecasting/model-outputs'
```

# Initialize
```{r}
# General purpose
library(tidyverse) # General
library(data.table) # General
library(devtools) # General
library(lubridate) # Dates
library(glue) # String Interpolation
# Data parse/import
library(jsonlite) # JSON Parser
library(rvest) # HTML Parser
library(httr) # CURL Interface
# SQL/Apache Spark
library(DBI) # SQL Interface
# library(RPostgres) # PostgreSQL
# library(rsparklyr) # Spark
# My package
devtools::load_all(path = PACKAGE_DIR)
devtools::document(PACKAGE_DIR)
# library(econforecasting)

# Set working directory
setwd(DIR)

# Read constants
source(file.path(INPUT_DIR, 'constants.r'))
```

## Load RDS
```{r}
local({
	
	rds = readRDS(M3_PATH)

	p <<- rds$p
	m <<- rds$m
	h <<- rds$h
})
```


# Input Prep

## Aggregate Inputs to Quarterly
```{r}
local({
	
	
	# Get historical forecasts
	histDf =
		h$flatDf %>%
		split(., .$varname)  %>%
		purrr::map_dfr(., function(x)
			# Get monthly data if it exists, quarterly otherwise
			x %>%
				{
					if ('m' %in% unique(x$freq)) dplyr::filter(., form == 'st' & freq == 'm')
					else dplyr::filter(., form == 'st' & freq == 'q')
				} %>%
				dplyr::transmute(., varname, freq, date, value)
			)

	
	# Get exogenous qualitative forecasts
	qualDf =
		m$qual$predFlat %>%
		dplyr::filter(., form == 'st') %>%
		dplyr::transmute(., scenarioname, varname, freq = 'm', date, value)
	

	# Iterate through scenarios, combine and aggregate to quarterly
	exogDfs =
		qualDf %>%
    	split(., .$scenarioname) %>%
		lapply(., function(x)
			dplyr::bind_rows(histDf, x) %>%
				dplyr::arrange(., varname, date) %>%
				dplyr::mutate(., strdate = paste0(year(date), 'Q', quarter(date))) %>%
				dplyr::group_by(., varname, strdate) %>%
				dplyr::group_split(.) %>%
				lapply(., function(y) {
					if (y$freq[[1]] == 'm' && nrow(y) == 3) tibble(varname = y$varname[[1]], value = mean(y$value), strdate = y$strdate[[1]])		else if (y$freq[[1]] == 'm' && nrow(y) < 3) NA
					else if (y$freq[[1]] == 'q') dplyr::select(y, varname, value, strdate)
					}) %>%
				purrr::keep(., function(x) is_tibble(x)) %>%
				dplyr::bind_rows(.) %>%
				dplyr::mutate(., date = econforecasting::strdateToDate(strdate)) %>%
				dplyr::select(., -strdate) %>%
				tidyr::pivot_wider(., names_from  = 'varname', values_from = 'value') %>%
				dplyr::arrange(., date) %>%
				dplyr::filter(., date >= as.Date('2010-01-01'))
			)

	
	exogFlat =
		exogDfs %>%
		purrr::imap_dfr(., function(x, i)
			tidyr::pivot_longer(x, -date, names_to = 'varname', values_to = 'value') %>%
				dplyr::mutate(., scenarioname = i) %>%
				na.omit(.)
		)

	
	m$csm$exogDfs <<- exogDfs
	m$csm$exogFlat <<- exogFlat
})
```



# CSM

## Forecast Periods
```{r}
local({
	
	# Pull start date by finding the first date where all CORE.ENDOG variables are non-empty
	startDate =
		m$csm$exogDfs$baseline %>%
		dplyr::select(., date, dplyr::filter(p$variablesDf, core_structural == 'core.endog')$varname) %>%
		dplyr::filter(., date >= as.Date('2020-01-01')) %>%
		tidyr::pivot_longer(., -date, names_to = 'varname') %>%
		dplyr::mutate(., notNa = ifelse(!is.na(value), 1, 0)) %>%
		dplyr::group_by(., date) %>%
		dplyr::summarize(., countNotNa = sum(notNa), .groups = 'drop') %>%
		dplyr::filter(., countNotNa == 0) %>%
		dplyr::arrange(., date) %>%
		head(., 1) %>%
		.$date
	
	
	# Pull end date by last date of CORE.EXOG variables
	endDate =
		m$csm$exogDfs$baseline %>%
	    dplyr::select(., date, dplyr::filter(p$variablesDf, core_structural == 'core.exog')$varname) %>%
	    dplyr::filter(., date >= as.Date('2020-01-01')) %>%
	    tidyr::pivot_longer(., -date, names_to = 'varname') %>%
	    dplyr::mutate(., isNa = ifelse(is.na(value), 1, 0)) %>%
	    dplyr::group_by(., date) %>%
	    dplyr::summarize(., countNa = sum(isNa), .groups = 'drop') %>%
	    dplyr::filter(., countNa == 0) %>%
	    dplyr::arrange(., date) %>%
	    tail(., 1) %>%
	    .$date

	
	
	m$csm$startDate <<- startDate
	m$csm$endDate <<- endDate
})
```

## CSM Forecasting - Quarterly (All)
```{r}
local({
    
	
	histDf =
		m$csm$exogDfs$baseline %>%
		dplyr::filter(., date < m$csm$startDate)
	
    # Create exog df - start 4 quarters before forecast start date
    exogDf =
		m$csm$exogDfs$baseline %>%
    	dplyr::filter(., date >= lubridate::add_with_rollback(m$csm$startDate, months(-12)) & date <= m$csm$endDate)
    	
    # Now collapse into single data frame - 60 forecast quarters + 4 historical months,
    # combining historical & exogenous, overwriting exogenous with historical if it exists
    # initDf =
    #     tibble(
    #         date = c(
    #             tail(histDf$date, 4),
    #             seq(add_with_rollback(tail(histDf$date, 1), months(3)), by = '3 month', length.out = 60)
    #             )
    #         ) %>%
    #     dplyr::left_join(
    #         .,
    #         dplyr::full_join(
    #             tidyr::pivot_longer(histDf, -date, values_to = 'hist'),
    #             tidyr::pivot_longer(exogDf, -date, values_to = 'exog'), by = c('name', 'date')
    #             ) %>%
    #             dplyr::mutate(., value = ifelse(is.na(hist), exog, hist)) %>%
    #             dplyr::select(., date, name, value) %>% tidyr::pivot_wider(.),
    #         by = 'date'
    #         )
    
    # Now create coefficient matrices
    # Get steady-state values
    ss =
        h$base$q %>%
        na.omit(.) %>%
        dplyr::filter(., date == max(date)) %>%
        dplyr::select(., -date) %>%
        purrr::transpose(.) %>%
        .[[1]]
    
    
    coefMatsIdentity =
        list(
            gdp =
        		tibble(gdp = 1, pce = -1 * ss$pce/ss$gdp, pdi = -1 * ss$pdi/ss$gdp, im = ss$im/ss$gdp, ex = -1 * ss$ex/ss$gdp, govt = -1 * ss$govt/ss$gdp)
            )
    
    # Get historical data
    histDfAll =
        histDf %>%
        dplyr::bind_cols(
            .,
            constant = 1,
            lapply(1:4, function(l)
                dplyr::transmute_if(histDf, is.numeric, function(x) dplyr::lag(x, l)) %>%
                    dplyr::rename_with(., function(x) paste0(x, '.l', l))
                )
            )

    
    # Iterate through equations
    eqnsList =
        list(
            pce = 'pce = constant + ue',
            pdin = 'pdin = constant + ue + _lma2.pdin',
            pdir = 'pdir = constant + ue + hpi + _lma2.pdir',
            im = 'im = constant + ue + _lma2.im',
            ex = 'ex = constant + ue + _lma2.ex',
            govt = 'govt = constant + _lma2.govt',
            pi = 'pi = constant + pid',
            pdi = 'pdi = pdin + pdir'
        )
    
    # Get estimated coefficient matrices
    coefMatsEstimated = purrr::map(eqnsList, function(eqn) {
        message(eqn)
        
        yCoef = eqn %>% str_split_fixed(., '=', 2) %>% .[1, 1] %>% str_squish(.)
        
        xCoefs =
            eqn %>%
            str_split_fixed(., '=', 2) %>%
            .[1, 2] %>%
            str_split(., '\\+') %>%
            .[[1]] %>%
            str_squish(.) %>%
            purrr::map_dfr(., function(x)
                if (str_detect(x, '_ma2')) tibble(coefname = paste0(str_replace(x, coll('_ma2.'), ''), c('', '.l1')), adj = .5)
                else if (str_detect(x, '_lma2')) tibble(coefname = paste0(str_replace(x, coll('_lma2.'), ''), c('.l1', '.l2')), adj = .25)
                else tibble(coefname = x, adj = 1)
                )
    
        inputDf =
            histDfAll %>%
            dplyr::select(., date, all_of(c(yCoef, xCoefs$coefname))) %>%
            na.omit(.)
        
        yMat = inputDf %>% dplyr::select(., all_of(yCoef)) %>% as.matrix(.)
        xMat = inputDf %>% dplyr::select(., all_of(xCoefs$coefname)) %>% as.matrix(.)
        
        
        coefRes =
            solve(t(xMat) %*% xMat) %*% (t(xMat) %*% yMat) %>%
            as.data.frame(.) %>%
            rownames_to_column(.) %>%
            setNames(., c('coefname', 'value')) %>%
            as_tibble(.) %>%
            dplyr::left_join(xCoefs, by = 'coefname') %>%
            dplyr::transmute(., coefname, value = value * adj * -1) %>%
            dplyr::bind_rows(tibble(coefname = yCoef, value = 1), .) %>%
            tidyr::pivot_wider(., names_from = 'coefname')
        
        return(coefRes)
    })

        
        
    # Seperate endogeneous (estimated) and exogenous matrices
    endogVars = names(c(coefMatsIdentity, coefMatsEstimated))
    
    coefMat =
        purrr::imap_dfr(c(coefMatsIdentity, coefMatsEstimated), function(x, i) dplyr::bind_cols(coefname = i, x)) %>%
        replace(., is.na(.), 0)
    
    
    # Pass accumulator new exogenous variables each time
    resDf = purrr::reduce(5:nrow(exogDf), function(df, .row) {
        
        allCoefDf =
            df %>%
            dplyr::bind_cols(
                .,
                constant = 1,
                lapply(1:4, function(l)
                    dplyr::transmute_if(df, is.numeric, function(x) dplyr::lag(x, l)) %>%
                        dplyr::rename_with(., function(x) paste0(x, '.l', l))
                    )
                ) %>%
            dplyr::select(., c('date', colnames(coefMat) %>% .[. != 'coefname'])) %>%
            .[.row, ]
        
        
        bMatVars = allCoefDf %>% tidyr::pivot_longer(., -date) %>% dplyr::filter(., is.na(value)) %>% .$name
        dMatVars = allCoefDf %>% tidyr::pivot_longer(., -date) %>% dplyr::filter(., !is.na(value)) %>% .$name
        # Only keep equations where not already filled
        cMat =
        	coefMat %>% dplyr::filter(., coefname %in% bMatVars) %>% dplyr::select(., all_of(dMatVars)) %>% as.matrix(.) %>%
        	{. * -1}
        aMat = coefMat %>% dplyr::filter(., coefname %in% bMatVars) %>% dplyr::select(., all_of(bMatVars)) %>% as.matrix(.)
        dMat = allCoefDf %>% dplyr::select(., dMatVars) %>% as.matrix(.) %>% t(.)
        
        bMat = solve(aMat) %*% (cMat %*% dMat)
        bMatVec = bMat %>% as.data.frame(.) %>% rownames_to_column(.) %>% {setNames(.$V1, .$rowname)}
        
        for (varname in names(bMatVec)) {
            df[[.row, varname]] = bMatVec[[varname]]
        }
        
        return(df)
    }, .init = exogDf)

})
```



## CSM Forecasting - Monthly De-Agg
```{r}

```


## Get structural model exogenous shock
```{r}
local({
    
    
    
    
})
```




# Combine with Nowcasts
## Merge CSM - NC
```{r}
local({
    

})
```
